<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è´¨æŠ¼ & åˆ†çº¢ (BSC)</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 128 128%22><text x=%220%22 y=%2290%22 font-size=%2290%22>ğŸ¤‘</text></svg>" type="image/svg+xml">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #1a1a2e;
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }

        .logo {
            font-size: 20px;
            font-weight: bold;
            color: #ffffff;
        }

        .connect-btn {
            background-color: #0066ff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s;
        }

        .connect-btn:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .connect-btn:hover:not(:disabled) {
            background-color: #0052cc;
        }

        .section {
            background-color: #16213e;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #e0e0e0;
        }

        .info-line {
            margin-bottom: 10px;
            color: #b0b0b0;
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            font-size: 16px;
            margin-top: 10px;
            transition: background-color 0.3s;
        }

        .btn-primary {
            background-color: #6441a5;
            color: white;
        }

        .btn-primary:hover {
            background-color: #533894;
        }

        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background-color: #c0392b;
        }

        .btn-outline {
            background-color: transparent;
            color: #b0b0b0;
            border: 1px solid #333;
        }

        .btn-outline:hover {
            background-color: #2d3436;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            color: #b0b0b0;
            font-size: 14px;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            background-color: #0f3460;
            border: 1px solid #333;
            border-radius: 5px;
            color: white;
            font-size: 16px;
        }

        .input-group input::placeholder {
            color: #666;
        }

        .stake-item {
            background-color: #0f3460;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        .stake-item .stake-info {
            font-size: 14px;
            margin-bottom: 5px;
            color: #b0b0b0;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 500;
        }

        .status.success {
            background-color: #27ae60;
            color: white;
        }

        .status.error {
            background-color: #c0392b;
            color: white;
        }

        .status.info {
            background-color: #3498db;
            color: white;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">è´¨æŠ¼ & åˆ†çº¢ (BSC)</div>
            <button id="connect-btn" class="connect-btn">è¿æ¥ MetaMask</button>
        </header>

        <div id="app-content" class="hidden">
            <div class="section">
                <div class="info-line">å¯é¢†å–åˆ†çº¢: <span id="pending-rewards">-</span> BNB</div>
            </div>

            <div class="section">
                <div class="section-title">æˆ‘çš„è´¨æŠ¼æ¡ç›®</div>
                <button id="refresh-stakes" class="btn btn-outline">åˆ·æ–°è´¨æŠ¼åˆ—è¡¨</button>
                <div id="stakes-list" style="margin-top: 15px;">
                    <div style="text-align: center; color: #666;">æš‚æ— è´¨æŠ¼è®°å½•</div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">æ“ä½œ</div>

                <div style="margin-bottom: 20px;">
                    <div class="section-title" style="font-size: 16px; margin-bottom: 10px;">é¢†å–åˆ†çº¢</div>
                    <button id="claim-rewards" class="btn btn-primary">é¢†å–åˆ†çº¢</button>
                </div>

                <div style="margin-bottom: 20px;">
                    <div class="section-title" style="font-size: 16px; margin-bottom: 10px;">è´¨æŠ¼ä»£å¸</div>
                    <div class="input-group">
                        <input type="text" id="stake-amount" placeholder="è¾“å…¥è´¨æŠ¼æ•°é‡">
                    </div>
                    <button id="approve-token" class="btn btn-outline">å…ˆæ‰¹å‡†ï¼ˆERC20 æˆæƒï¼‰</button>
                    <button id="stake-token" class="btn btn-primary">è´¨æŠ¼</button>
                </div>

                <div>
                    <div class="section-title" style="font-size: 16px; margin-bottom: 10px;">å–æ¶ˆè´¨æŠ¼ï¼ˆæŒ‰ç´¢å¼•ï¼‰</div>
                    <div class="input-group">
                        <input type="number" id="unstake-index" placeholder="è¾“å…¥è¦è§£é™¤çš„è´¨æŠ¼ç´¢å¼•ï¼ˆæ•´æ•°ï¼‰" min="0">
                    </div>
                    <button id="unstake-token" class="btn btn-danger">å–æ¶ˆè´¨æŠ¼ï¼ˆæŒ‰ç´¢å¼•ï¼‰</button>
                </div>
            </div>

            <div id="status" class="status" style="display: none;"></div>
        </div>

        <div id="welcome-content">
            <div class="section" style="text-align: center; padding: 40px 20px;">
                <div class="section-title" style="font-size: 24px; margin-bottom: 20px;">æ¬¢è¿ä½¿ç”¨è´¨æŠ¼ & åˆ†çº¢ DApp</div>
                <p style="margin-bottom: 30px; color: #b0b0b0;">è¯·è¿æ¥æ‚¨çš„ MetaMask é’±åŒ…ä»¥å¼€å§‹ä½¿ç”¨</p>
                <button id="welcome-connect-btn" class="btn btn-primary">è¿æ¥ MetaMask</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== åŸç”Ÿ JS å®ç°æ ¸å¿ƒå·¥å…·å‡½æ•°ï¼ˆæ— ä»»ä½•å¤–éƒ¨ä¾èµ–ï¼‰====================
        const CONTRACT_ADDRESS = '0xCb5c82879A56006d6eEF2d03391E48ff774919A2';
        const ABI = [{"inputs":[{"internalType":"address","name":"_memeToken","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"EnforcedPause","type":"error"},{"inputs":[],"name":"ExpectedPause","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"DividendDistributed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"admin","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"EmergencyWithdrawBNB","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"admin","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"EmergencyWithdrawMEME","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newBlocks","type":"uint256"}],"name":"LockBlocksUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"oldToken","type":"address"},{"indexed":false,"internalType":"address","name":"newToken","type":"address"}],"name":"MemeTokenUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newAmount","type":"uint256"}],"name":"MinLockAmountUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"RewardClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Staked","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"penalty","type":"uint256"}],"name":"Unstaked","type":"event"},{"inputs":[],"name":"BURN_ADDRESS","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"DISTRIBUTION_THRESHOLD","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PENALTY_RATE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"claimRewards","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"disableStaking","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"dividendPerToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"emergencyWithdrawBNB","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"emergencyWithdrawMEME","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"enableStaking","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getPendingRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"getUserStake","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"startBlock","type":"uint256"},{"internalType":"uint256","name":"unlockBlock","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getUserStakeCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lockBlocks","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"memeToken","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"minLockAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pendingBNB","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_blocks","type":"uint256"}],"name":"setLockBlocks","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_newMemeToken","type":"address"}],"name":"setMemeToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"setMinLockAmount","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"stake","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"totalStaked","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"unstake","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"userRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"userStakes","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"startBlock","type":"uint256"},{"internalType":"uint256","name":"dividendPerTokenAtStake","type":"uint256"}],"stateMutability":"view","type":"function"},{"stateMutability":"payable","type":"receive"}];

        // å·¥å…·å‡½æ•°ï¼šè§£æ Etherï¼ˆå­—ç¬¦ä¸²è½¬ weiï¼‰
        function parseEther(etherStr) {
            const ether = parseFloat(etherStr);
            if (isNaN(ether)) return '0';
            return (ether * 1e18).toString();
        }

        // å·¥å…·å‡½æ•°ï¼šæ ¼å¼åŒ– Etherï¼ˆwei è½¬å­—ç¬¦ä¸²ï¼‰
        function formatEther(weiStr) {
            const wei = BigInt(weiStr || '0');
            return (wei / BigInt(1e18)).toString();
        }

        // å·¥å…·å‡½æ•°ï¼šç”Ÿæˆå‡½æ•°ç­¾åå“ˆå¸Œï¼ˆå‰4å­—èŠ‚ï¼‰
        function getFunctionSignatureHash(functionName, params) {
            const funcStr = `${functionName}(${params.join(',')})`;
            const encoder = new TextEncoder();
            const data = encoder.encode(funcStr);
            return crypto.subtle.digest('SHA-256', data).then(hash => {
                const hashArray = Array.from(new Uint8Array(hash));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return hashHex.substring(0, 8);
            });
        }

        // å·¥å…·å‡½æ•°ï¼šç¼–ç åœ°å€å‚æ•°
        function encodeAddress(address) {
            return address.replace('0x', '').padStart(64, '0');
        }

        // å·¥å…·å‡½æ•°ï¼šç¼–ç  uint256 å‚æ•°
        function encodeUint256(value) {
            return BigInt(value).toString(16).padStart(64, '0');
        }

        // å·¥å…·å‡½æ•°ï¼šç¼–ç å‚æ•°
        async function encodeParams(functionAbi, params) {
            let data = '';
            for (let i = 0; i < functionAbi.inputs.length; i++) {
                const input = functionAbi.inputs[i];
                const param = params[i];
                switch (input.type) {
                    case 'address':
                        data += encodeAddress(param);
                        break;
                    case 'uint256':
                        data += encodeUint256(param);
                        break;
                    default:
                        throw new Error(`ä¸æ”¯æŒçš„å‚æ•°ç±»å‹: ${input.type}`);
                }
            }
            return data;
        }

        // å·¥å…·å‡½æ•°ï¼šç¼–ç å‡½æ•°è°ƒç”¨æ•°æ®
        async function encodeFunctionCall(functionName, params) {
            const funcAbi = ABI.find(f => f.name === functionName && f.type === 'function');
            if (!funcAbi) throw new Error(`å‡½æ•° ${functionName} ä¸å­˜åœ¨`);
            
            const paramTypes = funcAbi.inputs.map(input => input.type);
            const sigHash = await getFunctionSignatureHash(functionName, paramTypes);
            const paramData = await encodeParams(funcAbi, params);
            return `0x${sigHash}${paramData}`;
        }

        // ==================== æ ¸å¿ƒé€»è¾‘ ====================
        let currentAccount = null;
        let memeTokenAddress = null;

        // DOM å…ƒç´ 
        const connectBtn = document.getElementById('connect-btn');
        const welcomeConnectBtn = document.getElementById('welcome-connect-btn');
        const appContent = document.getElementById('app-content');
        const welcomeContent = document.getElementById('welcome-content');
        const pendingRewardsEl = document.getElementById('pending-rewards');
        const refreshStakesBtn = document.getElementById('refresh-stakes');
        const stakesListEl = document.getElementById('stakes-list');
        const claimRewardsBtn = document.getElementById('claim-rewards');
        const stakeAmountInput = document.getElementById('stake-amount');
        const approveTokenBtn = document.getElementById('approve-token');
        const stakeTokenBtn = document.getElementById('stake-token');
        const unstakeIndexInput = document.getElementById('unstake-index');
        const unstakeTokenBtn = document.getElementById('unstake-token');
        const statusEl = document.getElementById('status');

        // é¡µé¢åŠ è½½å®Œæˆåˆå§‹åŒ–
        window.addEventListener('load', () => {
            console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œåˆå§‹åŒ–äº‹ä»¶ç»‘å®š...');
            
            // ç»‘å®šæ‰€æœ‰æŒ‰é’®äº‹ä»¶
            connectBtn.addEventListener('click', connectWallet);
            welcomeConnectBtn.addEventListener('click', connectWallet);
            refreshStakesBtn.addEventListener('click', refreshStakes);
            claimRewardsBtn.addEventListener('click', claimRewards);
            approveTokenBtn.addEventListener('click', approveToken);
            stakeTokenBtn.addEventListener('click', stakeToken);
            unstakeTokenBtn.addEventListener('click', unstakeToken);

            console.log('äº‹ä»¶ç»‘å®šå®Œæˆï¼Œæ£€æµ‹ MetaMask...');
            console.log('window.ethereum å­˜åœ¨å—ï¼Ÿ', !!window.ethereum);
        });

        // è¿æ¥é’±åŒ…
        async function connectWallet() {
            try {
                console.log('å¼€å§‹è¿æ¥é’±åŒ…...');
                
                // ç¦ç”¨æŒ‰é’®
                connectBtn.disabled = true;
                connectBtn.textContent = 'è¿æ¥ä¸­...';
                welcomeConnectBtn.disabled = true;
                welcomeConnectBtn.textContent = 'è¿æ¥ä¸­...';
                
                // æ£€æµ‹ MetaMask
                if (!window.ethereum) {
                    throw new Error('æœªæ£€æµ‹åˆ° MetaMaskï¼Œè¯·å®‰è£…åé‡è¯•');
                }

                showStatus('æ­£åœ¨è¿æ¥ MetaMask...', 'info');
                
                // è¯·æ±‚æˆæƒ
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts || accounts.length === 0) {
                    throw new Error('ç”¨æˆ·æ‹’ç»äº†æˆæƒ');
                }

                currentAccount = accounts[0];
                console.log('é’±åŒ…è¿æ¥æˆåŠŸï¼Œè´¦æˆ·:', currentAccount);
                
                // è·å– MEME ä»£å¸åœ°å€
                await fetchMemeTokenAddress();
                
                // æ›´æ–° UI
                updateUIAfterConnect();
                showStatus('é’±åŒ…è¿æ¥æˆåŠŸï¼', 'success');
                
            } catch (error) {
                console.error('è¿æ¥å¤±è´¥:', error);
                showStatus(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                connectBtn.disabled = false;
                connectBtn.textContent = 'è¿æ¥ MetaMask';
                welcomeConnectBtn.disabled = false;
                welcomeConnectBtn.textContent = 'è¿æ¥ MetaMask';
            }
        }

        // è·å– MEME ä»£å¸åœ°å€
        async function fetchMemeTokenAddress() {
            try {
                const funcData = await encodeFunctionCall('memeToken', []);
                const result = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{ to: CONTRACT_ADDRESS, data: funcData }, 'latest']
                });
                // è§£æåœ°å€ï¼ˆæˆªå–å40ä¸ªå­—ç¬¦ï¼‰
                memeTokenAddress = `0x${result.slice(-40)}`;
                console.log('MEME ä»£å¸åœ°å€:', memeTokenAddress);
            } catch (error) {
                console.error('è·å–ä»£å¸åœ°å€å¤±è´¥:', error);
                throw new Error('æ— æ³•è·å–ä»£å¸åœ°å€ï¼Œè¯·é‡è¯•');
            }
        }

        // æ›´æ–°è¿æ¥åçš„ UI
        function updateUIAfterConnect() {
            connectBtn.textContent = `å·²è¿æ¥: ${currentAccount.substring(0, 6)}...${currentAccount.substring(38)}`;
            appContent.classList.remove('hidden');
            welcomeContent.classList.add('hidden');
            
            // åŠ è½½åˆå§‹æ•°æ®
            loadPendingRewards();
            refreshStakes();
        }

        // åŠ è½½å¯é¢†å–åˆ†çº¢
        async function loadPendingRewards() {
            try {
                const funcData = await encodeFunctionCall('getPendingRewards', [currentAccount]);
                const result = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{ to: CONTRACT_ADDRESS, data: funcData }, 'latest']
                });
                const rewards = formatEther(result);
                pendingRewardsEl.textContent = rewards;
            } catch (error) {
                console.error('è·å–åˆ†çº¢å¤±è´¥:', error);
                pendingRewardsEl.textContent = 'è·å–å¤±è´¥';
            }
        }

        // åˆ·æ–°è´¨æŠ¼åˆ—è¡¨
        async function refreshStakes() {
            try {
                showStatus('æ­£åœ¨åˆ·æ–°è´¨æŠ¼åˆ—è¡¨...', 'info');
                
                // è·å–è´¨æŠ¼æ•°é‡
                const countData = await encodeFunctionCall('getUserStakeCount', [currentAccount]);
                const countResult = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{ to: CONTRACT_ADDRESS, data: countData }, 'latest']
                });
                const stakeCount = parseInt(countResult, 16);
                
                if (stakeCount === 0) {
                    stakesListEl.innerHTML = '<div style="text-align: center; color: #666;">æš‚æ— è´¨æŠ¼è®°å½•</div>';
                    showStatus('è´¨æŠ¼åˆ—è¡¨å·²åˆ·æ–°', 'success');
                    return;
                }

                stakesListEl.innerHTML = '';
                
                // éå†æ‰€æœ‰è´¨æŠ¼è®°å½•
                for (let i = 0; i < stakeCount; i++) {
                    const stakeData = await encodeFunctionCall('getUserStake', [currentAccount, i]);
                    const stakeResult = await window.ethereum.request({
                        method: 'eth_call',
                        params: [{ to: CONTRACT_ADDRESS, data: stakeData }, 'latest']
                    });
                    
                    // è§£æè´¨æŠ¼æ•°æ®ï¼ˆ3ä¸ª uint256 å‚æ•°ï¼‰
                    const amount = formatEther(`0x${stakeResult.slice(2, 66)}`);
                    const startBlock = parseInt(`0x${stakeResult.slice(66, 130)}`, 16);
                    const unlockBlock = parseInt(`0x${stakeResult.slice(130, 194)}`, 16);
                    
                    const stakeItem = document.createElement('div');
                    stakeItem.className = 'stake-item';
                    stakeItem.innerHTML = `
                        <div class="stake-info">ç´¢å¼•: ${i}</div>
                        <div class="stake-info">æ•°é‡: ${amount} MEME</div>
                        <div class="stake-info">å¼€å§‹åŒºå—: ${startBlock}</div>
                        <div class="stake-info">è§£é”åŒºå—: ${unlockBlock}</div>
                    `;
                    stakesListEl.appendChild(stakeItem);
                }
                
                showStatus('è´¨æŠ¼åˆ—è¡¨å·²åˆ·æ–°', 'success');
            } catch (error) {
                console.error('åˆ·æ–°è´¨æŠ¼åˆ—è¡¨å¤±è´¥:', error);
                showStatus(`åˆ·æ–°å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // é¢†å–åˆ†çº¢
        async function claimRewards() {
            try {
                showStatus('æ­£åœ¨é¢†å–åˆ†çº¢...', 'info');
                
                const funcData = await encodeFunctionCall('claimRewards', []);
                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        to: CONTRACT_ADDRESS,
                        data: funcData,
                        from: currentAccount
                    }]
                });
                
                showStatus(`åˆ†çº¢äº¤æ˜“å·²å‘é€: ${txHash}`, 'success');
                
                // ç­‰å¾…äº¤æ˜“ç¡®è®¤ï¼ˆ5ç§’ååˆ·æ–°ï¼‰
                setTimeout(() => {
                    loadPendingRewards();
                    showStatus('åˆ†çº¢é¢†å–æˆåŠŸï¼', 'success');
                }, 8000);
            } catch (error) {
                console.error('é¢†å–åˆ†çº¢å¤±è´¥:', error);
                showStatus(`é¢†å–å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æˆæƒä»£å¸
        async function approveToken() {
            try {
                const amount = stakeAmountInput.value.trim();
                if (!amount || parseFloat(amount) <= 0) {
                    throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„è´¨æŠ¼æ•°é‡');
                }

                if (!memeTokenAddress) {
                    throw new Error('æœªè·å–åˆ°ä»£å¸åœ°å€ï¼Œè¯·å…ˆåˆ·æ–°é¡µé¢');
                }

                showStatus('æ­£åœ¨æˆæƒä»£å¸...', 'info');
                
                // ERC20 approve å‡½æ•°è°ƒç”¨
                const funcData = await encodeFunctionCall('approve', [CONTRACT_ADDRESS, parseEther(amount)]);
                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        to: memeTokenAddress,
                        data: funcData,
                        from: currentAccount
                    }]
                });
                
                showStatus(`æˆæƒäº¤æ˜“å·²å‘é€: ${txHash}`, 'success');
                
                setTimeout(() => {
                    showStatus('ä»£å¸æˆæƒæˆåŠŸï¼', 'success');
                }, 8000);
            } catch (error) {
                console.error('æˆæƒå¤±è´¥:', error);
                showStatus(`æˆæƒå¤±è´¥: ${error.message}`, 'error');
            }
        }

        // è´¨æŠ¼ä»£å¸
        async function stakeToken() {
            try {
                const amount = stakeAmountInput.value.trim();
                if (!amount || parseFloat(amount) <= 0) {
                    throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„è´¨æŠ¼æ•°é‡');
                }

                showStatus('æ­£åœ¨è´¨æŠ¼ä»£å¸...', 'info');
                
                const funcData = await encodeFunctionCall('stake', [parseEther(amount)]);
                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        to: CONTRACT_ADDRESS,
                        data: funcData,
                        from: currentAccount
                    }]
                });
                
                showStatus(`è´¨æŠ¼äº¤æ˜“å·²å‘é€: ${txHash}`, 'success');
                
                setTimeout(() => {
                    refreshStakes();
                    loadPendingRewards();
                    stakeAmountInput.value = '';
                    showStatus('è´¨æŠ¼æˆåŠŸï¼', 'success');
                }, 8000);
            } catch (error) {
                console.error('è´¨æŠ¼å¤±è´¥:', error);
                showStatus(`è´¨æŠ¼å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å–æ¶ˆè´¨æŠ¼
        async function unstakeToken() {
            try {
                const index = parseInt(unstakeIndexInput.value.trim());
                if (isNaN(index) || index < 0) {
                    throw new Error('è¯·è¾“å…¥æœ‰æ•ˆçš„è´¨æŠ¼ç´¢å¼•');
                }

                showStatus('æ­£åœ¨å–æ¶ˆè´¨æŠ¼...', 'info');
                
                const funcData = await encodeFunctionCall('unstake', [index]);
                const txHash = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        to: CONTRACT_ADDRESS,
                        data: funcData,
                        from: currentAccount
                    }]
                });
                
                showStatus(`å–æ¶ˆè´¨æŠ¼äº¤æ˜“å·²å‘é€: ${txHash}`, 'success');
                
                setTimeout(() => {
                    refreshStakes();
                    loadPendingRewards();
                    unstakeIndexInput.value = '';
                    showStatus('å–æ¶ˆè´¨æŠ¼æˆåŠŸï¼', 'success');
                }, 8000);
            } catch (error) {
                console.error('å–æ¶ˆè´¨æŠ¼å¤±è´¥:', error);
                showStatus(`å–æ¶ˆè´¨æŠ¼å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ˜¾ç¤ºçŠ¶æ€æç¤º
        function showStatus(message, type) {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';

            // æˆåŠŸä¿¡æ¯3ç§’åéšè—
            if (type === 'success') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }
    </script>
</body>
</html>
